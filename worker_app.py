# Generated by Web Automation Studio - Worker 1
# DEPLOYMENT INSTRUCTIONS FOR RENDER.COM (FREE)
# 1. Save this file as 'worker_app_1.py'.
# 2. Create a 'requirements.txt' file with the following content:
#    gunicorn
#    Flask==2.2.2
#    undetected-chromedriver
#    selenium
#    setuptools
# 3. Create a GitHub repository and upload both files.
# 4. On Render.com, create a new "Web Service" and connect your GitHub repo.
# 5. Use this 'Start Command' on Render: gunicorn worker_app_1:app
# 6. Copy the public URL (e.g., https://my-worker.onrender.com/execute) and add it to the Orchestrator UI.

from flask import Flask, request, jsonify
import undetected_chromedriver as uc
from selenium.webdriver.common.by import By
from selenium.webdriver.common.action_chains import ActionChains
import random
import time
import threading
import json

# ================== WORKER CONFIGURATION ==================
# This worker will use the following proxy:
PROXY_TO_USE = "http://167.71.5.83:3128"
# ==========================================================

app = Flask(__name__)

# Health check endpoint for Render.com
@app.route('/')
def health_check():
    return jsonify({"status": "online", "message": "Worker is ready to accept jobs at /execute."}), 200

def natural_mouse_move(driver):
    try:
        size = driver.get_window_size()
        for _ in range(random.randint(3, 7)):
            x = random.randint(100, size.get('width', 800) - 100)
            y = random.randint(100, size.get('height', 600) - 100)
            ActionChains(driver).move_by_offset(x - (size.get('width', 800)/2), y - (size.get('height', 600)/2)).pause(0.2).perform()
            time.sleep(random.uniform(0.4, 1.2))
    except Exception: pass

def execute_bot_task(task_details):
    target_url = task_details.get('target_url')
    min_stay = task_details.get('min_stay', 60)
    max_stay = task_details.get('max_stay', 180)
    headless = task_details.get('headless', True)
    use_custom_script = task_details.get('use_custom_script', False)
    action_sequence = task_details.get('action_sequence', [])

    print(f"WORKER: Received job for -> {target_url}")

    options = uc.ChromeOptions()
    if headless: options.add_argument("--headless")
    options.add_argument("--no-sandbox"); options.add_argument("--disable-blink-features=AutomationControlled")
    options.add_argument("--start-maximized"); options.add_argument("--disable-extensions")
    
    if PROXY_TO_USE:
        options.add_argument(f'--proxy-server={PROXY_TO_USE}')
        print(f"WORKER: Using proxy: {PROXY_TO_USE}")

    driver = None
    try:
        driver = uc.Chrome(options=options)
        print(f"WORKER: Starting session for -> {target_url}")
        driver.get(target_url)
        time.sleep(random.uniform(6, 14))

        if use_custom_script:
            print(f"WORKER: Executing {len(action_sequence)} commands from custom script.")
            for action in action_sequence:
                command = action.get('command')
                params = action.get('params', {})
                print(f"    > ACTION: {command} {json.dumps(params)}")
                try:
                    if command == 'GOTO':
                        path = params.get('value', '')
                        nav_url = target_url.rstrip('/') + path if path.startswith('/') else path
                        driver.get(nav_url)
                    elif command == 'WAIT':
                        time.sleep(int(params.get('value', 1)))
                    elif command == 'SCROLL':
                        driver.execute_script(f"window.scrollBy(0, {int(params.get('value', 500))});")
                    elif command == 'CLICK':
                        element = driver.find_element(By.CSS_SELECTOR, params.get('value'))
                        driver.execute_script("arguments[0].scrollIntoView({behavior: 'smooth', block: 'center'});", element)
                        time.sleep(1.5)
                        element.click()
                    elif command == 'TYPE':
                        element = driver.find_element(By.CSS_SELECTOR, params.get('selector'))
                        element.send_keys(params.get('text', ''))
                    time.sleep(random.uniform(1.5, 3))
                except Exception as e:
                    print(f"    > Could not execute command: {e}")
        else:
            # Standard random behavior
            for _ in range(random.randint(4, 10)):
                driver.execute_script(f"window.scrollBy(0, {random.randint(400, 1200)});")
                time.sleep(random.uniform(1.8, 5))
            natural_mouse_move(driver)

        stay = random.randint(min_stay, max_stay)
        print(f"WORKER: Staying for {stay} seconds...")
        time.sleep(stay)

    except Exception as e:
        print(f"WORKER: An error occurred: {e}")
    
    finally:
        if driver: driver.quit()
        print(f"WORKER: Session for {target_url} finished. âœ…\n")

@app.route('/execute', methods=['POST'])
def handle_execute_request():
    task_details = request.json
    if not task_details or not task_details.get('target_url'):
        return jsonify({"status": "error", "message": "Missing 'target_url' in request."}), 400
    
    # Run the bot task in a background thread so we can respond immediately
    thread = threading.Thread(target=execute_bot_task, args=(task_details,))
    thread.daemon = True
    thread.start()
    
    return jsonify({"status": "success", "message": "Task received and started in background."}), 202

if __name__ == "__main__":
    print("Starting Web Automation Worker...")
    print("Listening for jobs on the /execute endpoint.")
    # For production, use a proper WSGI server like Gunicorn or Waitress.
    # The 'app.run' line is for local testing only.
    app.run(host='0.0.0.0', port=5000)